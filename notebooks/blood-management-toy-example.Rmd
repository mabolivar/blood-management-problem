---
title: "R Notebook"
output: html_notebook
---

```{r params}
input_name <- "01-toy"
input_path <- "./notebooks/data/toy/"
```

```{python packages}
import pandas as pd
from math import ceil
from ortools.linear_solver import pywraplp
```


```{r libraries, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)
library(purrr)
library(stringr)
library(glue)
library("reticulate") # https://rstudio.github.io/reticulate/index.html
```

```{r read-data}

nodes <- read_csv(glue("{input_path}/{input_name}-nodes.csv"),
                  col_types = cols(
                    node = col_character(),
                    b = col_integer()
                    )
                  ) %>% 
  separate(node, into = c("type", "blood_type", "epoch"), remove = FALSE) %>% 
  mutate(epoch = as.numeric(epoch)) # ToDO: Validate this doesn't break anything

arcs <- read_csv(glue("{input_path}/{input_name}-arcs.csv"),
                 col_types = cols(
                   tail = col_character(),
                   head = col_character(),
                   reward = col_integer()
                   )
                 ) %>%
    separate(tail, into = c("tail_type", "tail_blood_type", "tail_epoch"), remove = FALSE) %>% 
    separate(head, into = c("head_type", "head_blood_type", "head_epoch"), remove = FALSE) %>% 
  mutate(tail_epoch = as.numeric(tail_epoch),
         head_epoch = as.numeric(head_epoch)) # ToDO: Validate this doesn't break anything
```

```{python transition_function}
def transition_function(_inventory, _donations, 
                        _demand, _allowed_blood_transfer,
                        _reward_map):
  # Requirements
  supply = {
    tuple(k.split("_")): v + _inventory.get(tuple(k.split("_")), 0)
    for k, v in _donations.items()
    }
  demand = {tuple(k.split("_")): v for k, v in _demand.items()}
  
  allowed_blood_transfers = set(
  (tuple(tail.split("_")), tuple(head.split("_")))
  for tail, head in _allowed_blood_transfer
  )
  reward_map= {(tuple(k[0].split("_")), tuple(k[1].split("_"))): v 
                for k, v in
                _reward_map.items()}
  return supply, demand, allowed_blood_transfers, reward_map

```

```{python create-network}
def create_network(supply, demand, allowed_blood_transfers, reward_map, V=dict()):
  # Create network
  supply_demand_arcs = [(s, d) for s in supply.keys() for d in demand.keys()
                        if (s, d) in allowed_blood_transfers]
  supply_nextsupply_arcs = [(s, ("f", s[0], s[1])) for s in supply]
  nextsupply_sink_arcs = [(("f", s[0], s[1]), (s[0], s[1], i))
                          for s in supply
                          for i in range(1, supply[s] + 1)]
  supplysink_sink = [((s[0], s[1], i), "sink") for s in supply for i in range(1, supply[s] + 1)]
  demand_sink_arcs = [(d, "sink") for d in demand]
  
  
  arcs = supply_demand_arcs + supply_nextsupply_arcs + nextsupply_sink_arcs + supplysink_sink + demand_sink_arcs
  
  head_nodes, tail_nodes = [set(nodes) for nodes in zip(*arcs)]
  nodes = set.union(head_nodes, tail_nodes)
  
  b = {**{n: s for n, s in supply.items()},
       **{n: 0 for n, d in demand.items()},
       **{"sink": -1 * sum(supply.values())}}
  upper = {
      **{arc: demand[arc[0]] for arc in demand_sink_arcs},
      **{arc: 1 for arc in supplysink_sink}
  }
  reward = {
      **{arc: reward_map[arc] for arc in supply_demand_arcs},
      **{arc: 0 for arc in supply_nextsupply_arcs},
      **{arc: V.get((arc[0][0], arc[0][1]), dict()).get(arc[0][2], 0)
         for arc in supplysink_sink}
  }
  
  return nodes, b, arcs, upper, reward

```


```{python solve-myopic}
def solve_network(nodes, b, arcs, upper, reward, print_model=False, print_solution=False):
  # Adjacency dictionary
  inner = {node: set() for node in nodes}
  outer = {node: set() for node in nodes}
  for arc in arcs:
      outer[arc[0]].add(arc[1])
      inner[arc[1]].add(arc[0])
  
  # Clear model
  mip_solver = pywraplp.Solver('simple_mip_program',
                                            pywraplp.Solver.CLP_LINEAR_PROGRAMMING)
  
  # A dictionary vars created to contain the referenced variables
  x = {(head, tail): mip_solver.NumVar(lb=0, ub=upper.get((head, tail), mip_solver.Infinity()),
                                            name=f'x_{head}_{tail}') for head, tail in arcs}
  
  # Balance constraint
  for i in nodes:
      mip_solver.Add(
          sum(x[i, j] for j in outer[i]) - sum(x[j, i] for j in inner[i]) == b.get(i, 0),
          name=str(i)
      )
  
  # Objective function
  reward_function = [x[arc] * reward for arc, reward in reward.items()]
  mip_solver.Maximize(mip_solver.Sum(reward_function))
  
  if print_model:
      print(mip_solver.ExportModelAsLpFormat(False))
  
  solver_status = mip_solver.Solve()
  
  if solver_status == pywraplp.Solver.OPTIMAL and print_solution:
      for name, v in x.items():
          if v.solution_value() >= 0.999:
              print(v.name(), ' = ', v.solution_value())
      print("Total Cost =", mip_solver.Objective().Value())
  
  optimal = (solver_status == pywraplp.Solver.OPTIMAL)
  solution = {
      'actions': {(arc[0], arc[1]): round(x[arc].solution_value())
                  for arc in arcs
                  if x[arc].solution_value() >= 0.999},
      'cost': (mip_solver.Objective().Value()
               if solver_status == pywraplp.Solver.OPTIMAL else None),
      'status': solver_status,
      'duals': {
          node: {'dual': mip_solver.LookupConstraint(str(node)).DualValue(),
                 "supply": b}
          for node, b in supply.items()
      }
  }
  return solution

```

## Get algorithm inputs

```{r network-inputs}
# First epoch
# Create input dictionaries
num_epochs <- max(as.integer(nodes$epoch))
donations <- dict()
demand <- dict()
allowed_blood_transfers <- dict()
reward_map <- dict()

for (i in 0:(num_epochs-1)){
  current_epoch <- i + 1
  supply_nodes <- nodes %>% filter(type == "s", epoch == current_epoch) %>% 
    mutate(node = glue("s_{blood_type}"))
  
  # Create demand dictionaries
  demand_nodes <- nodes %>% filter(type == "d", epoch == current_epoch) %>% 
    mutate(node = glue("d_{blood_type}"),
           b = -1 * b)
  
  # List for allowed blood transfers
  epoch_allowed_blood_transfers <- arcs %>% 
    filter(tail_epoch == current_epoch) %>% 
    mutate(tail = glue("s_{tail_blood_type}"), 
           head = glue("d_{head_blood_type}")) %>% 
    distinct(tail, head) %>% 
    pmap(.f=function(tail, head) {tuple(tail, head)})
  
  # Map all rewards
  rewards <- arcs %>% 
    filter(tail_epoch == current_epoch,
           reward != 0) %>% 
    transmute(tail = glue("s_{tail_blood_type}"), 
              head = glue("d_{head_blood_type}"),
              reward) 
  epoch_rewards <- py_dict(pmap(.l = rewards,
                                .f=function(tail, head, reward) {tuple(tail, head)}),
                           rewards$reward)
  
  py_set_item(donations, i, py_dict(supply_nodes$node, supply_nodes$b))
  py_set_item(demand, i, py_dict(demand_nodes$node, demand_nodes$b))
  py_set_item(allowed_blood_transfers, i, epoch_allowed_blood_transfers)
  py_set_item(reward_map, i, epoch_rewards)
}
```

```{python solution_to_df_func}
def solution_to_df(solution, num_iteration=None):
  epochs = solution.keys()
  actions_df = pd.concat(
    pd.DataFrame.from_dict(
    solution[t]["actions"], 
    orient = "index",
    columns=[ "flow"]
    )
    .reset_index()
    .rename(columns={"index":"arc"})
    .assign(epoch = t) for t in epochs
    )
  reward_df = pd.concat(
    pd.DataFrame.from_dict(
    solution[t]["rewards"], 
    orient = "index",
    columns=[ "reward"]
    )
    .reset_index()
    .rename(columns={"index":"arc"})
    .assign(epoch = t) for t in epochs
    )
  return (reward_df
          .merge(actions_df, how="left")
          .assign(iteration = num_iteration)
         )

```



## Intialization
```{python}
num_epochs = r["num_epochs"]
total_iterations = 5
total_rewards = [0] * total_iterations
iteration_solutions = [
  {epoch: dict() for epoch in range(num_epochs)} 
  for _ in range(total_iterations)
  ]
blood_nodes = [tuple(k.split("_")) for k in r["donations"][0].keys()]
V = {epoch: {b: dict() for b in blood_nodes} for epoch in range(num_epochs)}
```


## 1st iteration
### 1st epoch

```{python}
# Get input
num_iteration = 0
epoch = 0
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=dict(), 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
### 2nd epoch

```{python}
# Get input
inventory = {s: base_solution["actions"].get((s, ("f", s[0], s[1])), 0) for s in supply}
epoch = 1
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=inventory, 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```

#### Get v (duals)
```{python}
duals = dict()
for k, v in b.items():
  if k[0] == "s" and k != "sink":
    b[k]= v + 1
    b['sink']-= 1
    sol = solve_network(nodes, b, arcs, upper, reward)
    duals[k] = {"dual": sol["cost"] - base_solution["cost"], "supply": v + 1}
    b[k] = v
    b['sink']+= 1

```


#### Update Value function
```{python}
alpha = ceil(0.5 * (1 - (num_iteration + 1) / total_iterations))
for node, v in duals.items():
  V_update = V[epoch - 1][node]
  V_update[v["supply"]] = (1-alpha) * (V_update.get(v["supply"], 0)) + (alpha) * v["dual"]

#' ToDo: Maintain Monotonically

```

## 2st iteration
### 1st epoch
```{python}
# Get input
num_iteration += 1
epoch = 0
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=dict(), 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
### 2nd epoch

```{python}
# Get input
inventory = {s: base_solution["actions"].get((s, ("f", s[0], s[1])), 0) for s in supply}
epoch += 1
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=inventory, 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
#### Get v (duals)
```{python}
duals = dict()
for k, v in b.items():
  if k[0] == "s" and k != "sink":
    b[k]= v + 1
    b['sink']-= 1
    sol = solve_network(nodes, b, arcs, upper, reward)
    duals[k] = {"dual": sol["cost"] - base_solution["cost"], "supply": v + 1}
    b[k] = v
    b['sink']+= 1

```


#### Update Value function
```{python}
alpha = ceil(0.5 * (1 - (num_iteration + 1) / total_iterations))
for node, v in duals.items():
  V_update = V[epoch - 1][node]
  V_update[v["supply"]] = (1-alpha) * (V_update.get(v["supply"], 0)) + (alpha) * v["dual"]

#' ToDo: Maintain Monotonically

```

## 3st iteration
### 1st epoch
```{python}
# Get input
num_iteration += 1
epoch = 0
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=dict(), 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
### 2nd epoch

```{python}
# Get input
inventory = {s: base_solution["actions"].get((s, ("f", s[0], s[1])), 0) for s in supply}
epoch += 1
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=inventory, 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
#### Get v (duals)
```{python}
duals = dict()
for k, v in b.items():
  if k[0] == "s" and k != "sink":
    b[k]= v + 1
    b['sink']-= 1
    sol = solve_network(nodes, b, arcs, upper, reward)
    duals[k] = {"dual": sol["cost"] - base_solution["cost"], "supply": v + 1}
    b[k] = v
    b['sink']+= 1

```


#### Update Value function
```{python}
alpha = ceil(0.5 * (1 - (num_iteration + 1) / total_iterations))
for node, v in duals.items():
  V_update = V[epoch - 1][node]
  V_update[v["supply"]] = (1-alpha) * (V_update.get(v["supply"], 0)) + (alpha) * v["dual"]

#' ToDo: Maintain Monotonically

```

## 4st iteration
### 1st epoch
```{python}
# Get input
num_iteration += 1
epoch = 0
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=dict(), 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
### 2nd epoch

```{python}
# Get input
inventory = {s: base_solution["actions"].get((s, ("f", s[0], s[1])), 0) for s in supply}
epoch += 1
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=inventory, 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
#### Get v (duals)
```{python}
duals = dict()
for k, v in b.items():
  if k[0] == "s" and k != "sink":
    b[k]= v + 1
    b['sink']-= 1
    sol = solve_network(nodes, b, arcs, upper, reward)
    duals[k] = {"dual": sol["cost"] - base_solution["cost"], "supply": v + 1}
    b[k] = v
    b['sink']+= 1

```


#### Update Value function
```{python}
alpha = ceil(0.5 * (1 - (num_iteration + 1) / total_iterations))
for node, v in duals.items():
  V_update = V[epoch - 1][node]
  V_update[v["supply"]] = (1-alpha) * (V_update.get(v["supply"], 0)) + (alpha) * v["dual"]

#' ToDo: Maintain Monotonically
print(V)
```


## 5st iteration
### 1st epoch
```{python}
# Get input
num_iteration += 1
epoch = 0
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=dict(), 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
### 2nd epoch

```{python}
# Get input
inventory = {s: base_solution["actions"].get((s, ("f", s[0], s[1])), 0) for s in supply}
epoch += 1
supply, demand, allowed_blood_transfers, reward_map = transition_function(
  _inventory=inventory, 
  _donations=r["donations"][epoch], 
  _demand=r["demand"][epoch], 
  _allowed_blood_transfer=r["allowed_blood_transfers"][epoch],
  _reward_map=r["reward_map"][epoch]
  )

# Get network
nodes, b, arcs, upper, reward = create_network(
  supply, 
  demand, 
  allowed_blood_transfers, 
  reward_map,
  V = V[epoch]
  )
# Solve network
base_solution = solve_network(nodes, b, arcs, upper, reward)
total_rewards[num_iteration] += base_solution["cost"]
iteration_solutions[num_iteration][epoch] = {
  "actions": base_solution["actions"],
  "rewards": reward
  }
```
#### Get v (duals)
```{python}
duals = dict()
for k, v in b.items():
  if k[0] == "s" and k != "sink":
    b[k]= v + 1
    b['sink']-= 1
    sol = solve_network(nodes, b, arcs, upper, reward)
    duals[k] = {"dual": sol["cost"] - base_solution["cost"], "supply": v + 1}
    b[k] = v
    b['sink']+= 1

```


#### Update Value function
```{python}
alpha = ceil(0.5 * (1 - (num_iteration + 1) / total_iterations))
for node, v in duals.items():
  V_update = V[epoch - 1][node]
  V_update[v["supply"]] = (1-alpha) * (V_update.get(v["supply"], 0)) + (alpha) * v["dual"]

#' ToDo: Maintain Monotonically
print(V)
```

```{python}
solution_df  = (pd.concat(
  solution_to_df(iteration_solutions[i], i) 
  for i in range(total_iterations)
  )
  .reset_index()
  .assign(
    tail=lambda x: x.arc.apply(lambda y: y[0]),
    head=lambda x: x.arc.apply(lambda y: y[1])
  )
  # [lambda x: (x["tail"].apply(lambda y: len(y) <= 2) & 
  #               x["head"].apply(lambda y: len(y) > 2)) | 
  #               x["head"].apply(lambda y: y[0] == "f")]
  .assign(
    tail=lambda x: x["tail"].astype(str),
    head=lambda x: x["head"].astype(str),
    arc=lambda x: x.arc.astype(str)
)
)
```


```{r message=FALSE, warning=FALSE}
space_per_blood <- 3
offset_inventory_y <- 1
offset_inventory_x <- 0.7
offset_f_x <- 0.5
offset_demand_x <- 0.4

# Build positioning map
positioning_map <- nodes %>% 
  transmute(blood = blood_type, type, epoch = as.integer(epoch) - 1) %>% 
  mutate(
    x_pos = epoch + offset_demand_x * (type == "d"),
    blood_y_pos = (as.numeric(factor(blood)) - 1) * space_per_blood,
    type_y_pos = 1/2 * space_per_blood + 1/4 * space_per_blood * (type == "d")
    )

# Get arcs details
separeted_arcs <- py["solution_df"] %>% 
  mutate(tail_cleaned = str_replace_all(tail, "[^[:alnum:],]+", "") %>%
           str_remove("f,") %>% 
           paste0(., if_else(str_detect(tail,"^\\('f',"),",f","")),
         head_cleaned = str_replace_all(head, "[^[:alnum:],]+", "") %>%
           str_remove("f,") %>% 
           paste0(., if_else(str_detect(head,"^\\('f',"),",f",""))
         ) %>% 
  separate(tail_cleaned, 
           into = c("tail_type","tail_blood", "tail_other"), 
           extra = "merge",
           fill = "right") %>%
  separate(head_cleaned, 
           into = c("head_type","head_blood", "head_other"), 
           extra = "merge",
           fill = "right")

# Build node positioning for plotting
nodes_wpos <- bind_rows(
  separeted_arcs %>%
    filter(flow > 0) %>%
    select(
         iteration,
         epoch,
         node = tail,
         type = tail_type,
         blood = tail_blood,
         other = tail_other),
  separeted_arcs %>% 
    filter(flow > 0 | head_type == "d") %>% 
    select(
         iteration,
         epoch, 
         node = head, 
         type = head_type, 
         blood = head_blood, 
         other = head_other),
  ) %>% 
  distinct() %>% 
  left_join(positioning_map, by = c("epoch", "type", "blood")) %>% 
  # Fix ypos for parallel arcs
  group_by(iteration, epoch, type, blood) %>% 
  mutate(
    num_other = as.numeric(other),
    mean_other = mean(num_other, na.rm = T),
    step_inv = if_else(
      is.na(num_other),
      0.0,
      2 * offset_inventory_y / (max(num_other, na.rm = T) - min(num_other, na.rm = T))),
    blood_y_pos = blood_y_pos + case_when(is.na(num_other) ~ 0,
                                           TRUE ~ (num_other - mean_other) * step_inv)
    ) %>% 
  ungroup() %>% 
  mutate(x_pos = x_pos + case_when(is.na(other) ~ 0,
                           !is.na(num_other) ~ offset_inventory_x,
                           other == "f" ~ offset_f_x),
         y_pos = blood_y_pos + type_y_pos) %>% 
  arrange(iteration, epoch, type, blood, other) %>% 
  select(-blood_y_pos, -type_y_pos, -num_other, -mean_other, -step_inv) %>% 
  # Add supply/demand values
  left_join(nodes %>% transmute(epoch = epoch -1, blood = blood_type, type, b), 
            by = c("epoch", "type", "blood")) %>% 
  mutate(b = if_else(!is.na(other), as.integer(NA), b))
  
# Add position to arcs
arcs_wpos <- separeted_arcs %>%
  filter(flow > 0) %>% 
  select(iteration, epoch, tail, head, reward, flow,
         ends_with("_type"), ends_with("_blood"), ends_with("_other")) %>% 
  inner_join(nodes_wpos %>% 
              select(-node, -b) %>% 
              rename(tail_x_pos = x_pos,
                     tail_y_pos = y_pos), 
            by=c("iteration", "epoch", 
                 "tail_type"="type", 
                 "tail_blood"="blood",
                 "tail_other"="other")
  ) %>% 
  inner_join(nodes_wpos %>% 
              select(-node, -b)%>% 
              rename(head_x_pos = x_pos,
                     head_y_pos = y_pos), 
            by=c("iteration", "epoch", 
                 "head_type"="type", 
                 "head_blood"="blood",
                 "head_other"="other")
  ) %>% 
  select(iteration:flow, tail_x_pos, tail_y_pos, head_x_pos, head_y_pos, everything())

```

```{r plot-iterations, warning=FALSE}

ggplot() +
  geom_point(data = nodes_wpos, aes(x = x_pos, y = y_pos, color = type)) +
  geom_text(data = nodes_wpos, aes(x = x_pos, y = y_pos, label = b), size = 2) +
  geom_segment(data=arcs_wpos,
               mapping=aes(x = tail_x_pos, y = tail_y_pos,
                           xend= head_x_pos, yend=head_y_pos,
                           linetype="line_type"),
               lineend="round",
               arrow=arrow(0.02)) + 
  scale_y_reverse() + 
  facet_wrap(iteration ~ .)

now_str = lubridate::now() %>% str_remove_all("[^[:alnum:]]+")
ggsave(glue("notebooks/figures/raw/toy_plotting_{now_str}.png"),
       width = 8, height = 5)

```
